"""
Trading Strategy Engine

This module implements the EMA Crossover strategy.
It is completely decoupled from Alpaca or any specific data source.

The strategy only generates signals (BUY/SELL) based on indicator calculations.
It never places orders or interacts with any trading platform.
"""

from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime
from decimal import Decimal
from enum import Enum
from typing import List, Optional
import logging

logger = logging.getLogger(__name__)


class SignalType(Enum):
    """Trading signal types"""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"


@dataclass
class Bar:
    """
    Generic bar/candlestick data structure.
    This is independent of Alpaca's format.
    """
    timestamp: datetime
    open: Decimal
    high: Decimal
    low: Decimal
    close: Decimal
    volume: Decimal

    @classmethod
    def from_alpaca_bar(cls, bar_dict: dict) -> Bar:
        """Convert Alpaca bar format to our generic Bar"""
        return cls(
            timestamp=datetime.fromisoformat(bar_dict['t'].replace('Z', '+00:00')),
            open=Decimal(str(bar_dict['o'])),
            high=Decimal(str(bar_dict['h'])),
            low=Decimal(str(bar_dict['l'])),
            close=Decimal(str(bar_dict['c'])),
            volume=Decimal(str(bar_dict['v']))
        )


@dataclass
class Signal:
    """Trading signal generated by strategy"""
    timestamp: datetime
    signal_type: SignalType
    price: Decimal
    fast_ema: Optional[Decimal] = None
    slow_ema: Optional[Decimal] = None
    reason: Optional[str] = None


class EMACalculator:
    """
    Exponential Moving Average calculator.
    Uses a clean, testable implementation.
    """
    
    @staticmethod
    def calculate(prices: List[Decimal], period: int) -> List[Optional[Decimal]]:
        """
        Calculate EMA for a list of prices.
        
        Returns a list of the same length, with None for periods where EMA can't be calculated.
        Uses the standard EMA formula: EMA = (Price - Previous EMA) * multiplier + Previous EMA
        where multiplier = 2 / (period + 1)
        """
        if len(prices) < period:
            return [None] * len(prices)
        
        result: List[Optional[Decimal]] = [None] * len(prices)
        multiplier = Decimal(2) / Decimal(period + 1)
        
        # Initialize with SMA for the first period
        sma = sum(prices[:period]) / Decimal(period)
        result[period - 1] = sma
        
        # Calculate EMA for remaining values
        for i in range(period, len(prices)):
            ema = (prices[i] - result[i - 1]) * multiplier + result[i - 1]
            result[i] = ema
        
        return result


class EMACrossoverStrategy:
    """
    EMA Crossover Trading Strategy
    
    Generates BUY signal when fast EMA crosses above slow EMA.
    Generates SELL signal when fast EMA crosses below slow EMA.
    
    This class is pure business logic - no external dependencies.
    """
    
    def __init__(
        self,
        fast_period: int = 9,
        slow_period: int = 21,
        stop_loss_percent: Optional[Decimal] = None,
        take_profit_percent: Optional[Decimal] = None
    ):
        """
        Initialize strategy with parameters.
        
        Args:
            fast_period: Period for fast EMA
            slow_period: Period for slow EMA
            stop_loss_percent: Stop loss as percentage (e.g., 2.5 for 2.5%)
            take_profit_percent: Take profit as percentage (e.g., 5.0 for 5%)
        """
        if fast_period >= slow_period:
            raise ValueError("Fast EMA period must be less than slow EMA period")
        
        self.fast_period = fast_period
        self.slow_period = slow_period
        self.stop_loss_percent = stop_loss_percent
        self.take_profit_percent = take_profit_percent
    
    def generate_signals(self, bars: List[Bar]) -> List[Signal]:
        """
        Generate trading signals from a list of bars.
        
        Args:
            bars: List of historical bars (must be sorted chronologically)
        
        Returns:
            List of signals generated
        """
        if len(bars) < self.slow_period:
            logger.warning(f"Not enough bars ({len(bars)}) for strategy (need {self.slow_period})")
            return []
        
        # Extract close prices
        closes = [bar.close for bar in bars]
        
        # Calculate EMAs
        fast_emas = EMACalculator.calculate(closes, self.fast_period)
        slow_emas = EMACalculator.calculate(closes, self.slow_period)
        
        # Store latest EMA values for monitoring
        if len(fast_emas) > 0 and fast_emas[-1] is not None:
            self._last_fast_ema = Decimal(str(fast_emas[-1]))
        if len(slow_emas) > 0 and slow_emas[-1] is not None:
            self._last_slow_ema = Decimal(str(slow_emas[-1]))
        
        # Detect crossovers and generate signals
        signals: List[Signal] = []
        
        for i in range(1, len(bars)):
            # Skip if EMAs not available yet
            if fast_emas[i] is None or slow_emas[i] is None:
                continue
            if fast_emas[i-1] is None or slow_emas[i-1] is None:
                continue
            
            prev_fast = fast_emas[i-1]
            prev_slow = slow_emas[i-1]
            curr_fast = fast_emas[i]
            curr_slow = slow_emas[i]
            
            # Only log signals from the last 5 bars to avoid spam
            should_log = i >= len(bars) - 5
            
            # Bullish crossover: fast crosses above slow
            if prev_fast <= prev_slow and curr_fast > curr_slow:
                signal = Signal(
                    timestamp=bars[i].timestamp,
                    signal_type=SignalType.BUY,
                    price=bars[i].close,
                    fast_ema=curr_fast,
                    slow_ema=curr_slow,
                    reason="Fast EMA crossed above slow EMA"
                )
                signals.append(signal)
                if should_log:
                    logger.info(f"BUY signal at {bars[i].timestamp}: price={bars[i].close}, fast={curr_fast:.2f}, slow={curr_slow:.2f}")
            
            # Bearish crossover: fast crosses below slow
            elif prev_fast >= prev_slow and curr_fast < curr_slow:
                signal = Signal(
                    timestamp=bars[i].timestamp,
                    signal_type=SignalType.SELL,
                    price=bars[i].close,
                    fast_ema=curr_fast,
                    slow_ema=curr_slow,
                    reason="Fast EMA crossed below slow EMA"
                )
                signals.append(signal)
                if should_log:
                    logger.info(f"SELL signal at {bars[i].timestamp}: price={bars[i].close}, fast={curr_fast:.2f}, slow={curr_slow:.2f}")
        
        return signals
    
    def calculate_stop_loss(self, entry_price: Decimal, side: str) -> Optional[Decimal]:
        """
        Calculate stop loss price.
        
        Args:
            entry_price: Entry price of the position
            side: "buy" or "sell"
        
        Returns:
            Stop loss price or None if not configured
        """
        if self.stop_loss_percent is None:
            return None
        
        if side.lower() == "buy":
            # For long positions, stop loss is below entry
            return entry_price * (Decimal(1) - self.stop_loss_percent / Decimal(100))
        else:
            # For short positions, stop loss is above entry
            return entry_price * (Decimal(1) + self.stop_loss_percent / Decimal(100))
    
    def calculate_take_profit(self, entry_price: Decimal, side: str) -> Optional[Decimal]:
        """
        Calculate take profit price.
        
        Args:
            entry_price: Entry price of the position
            side: "buy" or "sell"
        
        Returns:
            Take profit price or None if not configured
        """
        if self.take_profit_percent is None:
            return None
        
        if side.lower() == "buy":
            # For long positions, take profit is above entry
            return entry_price * (Decimal(1) + self.take_profit_percent / Decimal(100))
        else:
            # For short positions, take profit is below entry
            return entry_price * (Decimal(1) - self.take_profit_percent / Decimal(100))
    
    def should_exit_on_stop_loss(
        self, 
        entry_price: Decimal, 
        current_price: Decimal, 
        side: str
    ) -> bool:
        """
        Check if position should be exited due to stop loss.
        
        Args:
            entry_price: Entry price of the position
            current_price: Current market price
            side: "buy" or "sell"
        
        Returns:
            True if stop loss hit
        """
        stop_loss = self.calculate_stop_loss(entry_price, side)
        if stop_loss is None:
            return False
        
        if side.lower() == "buy":
            return current_price <= stop_loss
        else:
            return current_price >= stop_loss
    
    def should_exit_on_take_profit(
        self, 
        entry_price: Decimal, 
        current_price: Decimal, 
        side: str
    ) -> bool:
        """
        Check if position should be exited due to take profit.
        
        Args:
            entry_price: Entry price of the position
            current_price: Current market price
            side: "buy" or "sell"
        
        Returns:
            True if take profit hit
        """
        take_profit = self.calculate_take_profit(entry_price, side)
        if take_profit is None:
            return False
        
        if side.lower() == "buy":
            return current_price >= take_profit
        else:
            return current_price <= take_profit
